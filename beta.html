<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mediapilot</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #000; color: #fff; }
    h1 { text-align: center; }
    .container { max-width: 700px; margin: auto; background: #111; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.06); }
    input, button, select { width: 100%; padding: 10px; margin: 8px 0; border-radius: 5px; border: 1px solid #444; font-size: 16px; background: #222; color: #fff; }
    button { cursor: pointer; background: #007bff; border: none; }
    button:hover { background: #0056b3; }
    ul { padding-left: 0; list-style: none; }
    li { background: #222; padding: 10px; border-radius: 5px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; cursor: grab; }
    li.dragging { opacity: 0.3; }
    .remove { background: #ff4d4d; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; }
    #convertStatus { font-size: 14px; color: #ddd; }
    .small { font-size: 13px; color:#aaa; }
  </style>
  <!-- ffmpeg.wasm (core will be fetched from CDN) -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>mediapilot</h1>

    <input id="listName" placeholder="name your list (christmas movies)" />
    <input id="itemInput" placeholder="add anything (sarah by tyler the creator)" />
    <button onclick="addItem()">submit</button>

    <ul id="list"></ul>

    <button onclick="exportList()">export json</button>

    <input type="file" id="fileInput" accept="application/json" style="display:none;" onchange="importList()" />
    <button onclick="document.getElementById('fileInput').click()">import json</button>

    <hr style="margin:20px 0; border-color:#333;" />

    <h2>Convert Media</h2>
    <input type="file" id="mediaConvertInput" accept="image/*,video/*" />

    <label>Convert to format:</label>
    <select id="formatSelect">
      <option value="jpg">JPG (image)</option>
      <option value="png">PNG (image)</option>
      <option value="webp">WEBP (image)</option>
      <option value="mp4">MP4 (video)</option>
      <option value="webm">WEBM (video)</option>
    </select>

    <button onclick="convertMedia()">convert file</button>
    <p id="convertStatus"></p>
    <p class="small">Note: image conversions use the browser (fast). Video conversions use ffmpeg.wasm and can be large/slow and may not support all codecs in the browser build.</p>
  </div>

  <script>
    // --- list functionality (unchanged) ---
    let mediaList = [];

    function renderList() {
      const ul = document.getElementById('list');
      ul.innerHTML = '';
      mediaList.forEach((item, index) => {
        const li = document.createElement('li');
        // use a span so we can reliably read textContent even with the remove button
        const span = document.createElement('span');
        span.textContent = item;
        li.appendChild(span);

        li.draggable = true;
        li.dataset.index = index;

        li.addEventListener('dragstart', () => li.classList.add('dragging'));
        li.addEventListener('dragend', () => {
          li.classList.remove('dragging');
          // update mediaList order from DOM
          const newOrder = [...document.querySelectorAll('#list li')].map(li => li.querySelector('span').textContent);
          mediaList = newOrder;
        });

        const btn = document.createElement('button');
        btn.textContent = 'X';
        btn.className = 'remove';
        btn.onclick = () => removeItem(index);

        li.appendChild(btn);
        ul.appendChild(li);
      });
    }

    function addItem() {
      const input = document.getElementById('itemInput');
      if (input.value.trim() !== '') {
        mediaList.push(input.value.trim());
        input.value = '';
        renderList();
      }
    }

    function removeItem(index) {
      mediaList.splice(index, 1);
      renderList();
    }

    function exportList() {
      const data = { name: document.getElementById('listName').value, items: mediaList };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'media-list.json'; a.click(); URL.revokeObjectURL(url);
    }

    function importList() {
      const file = document.getElementById('fileInput').files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try { const data = JSON.parse(e.target.result); document.getElementById('listName').value = data.name||''; mediaList = data.items||[]; renderList(); }
        catch { alert('Invalid JSON file'); }
      };
      reader.readAsText(file);
    }

    // drag reorder
    const ul = document.getElementById('list');
    ul.addEventListener('dragover', e => {
      e.preventDefault();
      const dragging = document.querySelector('.dragging');
      const after = getDragAfter(ul, e.clientY);
      if (!dragging) return;
      if (after == null) ul.appendChild(dragging); else ul.insertBefore(dragging, after);
    });

    function getDragAfter(container, y) {
      const items = [...container.querySelectorAll('li:not(.dragging)')];
      return items.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height/2;
        if (offset < 0 && offset > closest.offset) return { offset, element: child };
        return closest;
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // --- media conversion ---
    // We'll convert images using an offscreen canvas (reliable and fast).
    // For videos, we use ffmpeg.wasm. Note: the ffmpeg core is fetched from CDN and may fail on very strict networks.

    async function convertMedia() {
      const fileInput = document.getElementById('mediaConvertInput');
      const file = fileInput.files[0];
      const format = document.getElementById('formatSelect').value;
      const status = document.getElementById('convertStatus');

      if (!file) { status.textContent = 'Select a file first.'; return; }

      const isImage = file.type.startsWith('image/');
      const isVideo = file.type.startsWith('video/');

      // IMAGE conversion (use canvas)
      if (isImage && (format === 'jpg' || format === 'png' || format === 'webp')) {
        status.textContent = 'Converting image in-browser...';
        try {
          const dataUrl = await fileToDataURL(file);
          const img = await loadImage(dataUrl);
          const canvas = document.createElement('canvas');
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          const mime = format === 'jpg' ? 'image/jpeg' : (format === 'png' ? 'image/png' : 'image/webp');
          canvas.toBlob(blob => {
            const outName = file.name.replace(/\.[^.]+$/, '') + '.' + format;
            downloadBlob(blob, outName);
            status.textContent = 'Done — image downloaded.';
          }, mime, 0.92);
        } catch (err) {
          console.error(err);
          status.textContent = 'Image conversion failed.';
        }
        return;
      }

      // VIDEO conversion (use ffmpeg.wasm) — this can be slow and large
      if (isVideo && (format === 'mp4' || format === 'webm')) {
        status.textContent = 'Loading ffmpeg (may take a few seconds)...';
        const { createFFmpeg, fetchFile } = FFmpeg;
        // point corePath explicitly to reduce chance of a bad core lookup
        const ffmpeg = createFFmpeg({ log: true, corePath: 'https://unpkg.com/@ffmpeg/core@0.11.1/dist/ffmpeg-core.js' });
        try {
          ffmpeg.setProgress(({ ratio }) => {
            status.textContent = `Converting... ${Math.round(ratio * 100)}%`;
          });
          await ffmpeg.load();
        } catch (err) {
          console.error('ffmpeg load failed', err);
          status.textContent = 'Failed to load ffmpeg — check network or try a different browser.';
          return;
        }

        try {
          const inputName = 'input' + getFileExtension(file.name);
          const outputName = 'output.' + format;
          ffmpeg.FS('writeFile', inputName, await fetchFile(file));

          // use a safe conversion command; note: advanced codec options may not be available in wasm build
          if (format === 'mp4') {
            // attempt an mp4 copy; fallback to default encode if copy fails
            try {
              await ffmpeg.run('-i', inputName, '-c:v', 'libx264', '-preset', 'fast', '-c:a', 'aac', outputName);
            } catch (e) {
              console.warn('libx264/aac not available; trying a simpler command', e);
              await ffmpeg.run('-i', inputName, outputName);
            }
          } else {
            await ffmpeg.run('-i', inputName, outputName);
          }

          const data = ffmpeg.FS('readFile', outputName);
          const blob = new Blob([data.buffer], { type: format === 'mp4' ? 'video/mp4' : 'video/webm' });
          downloadBlob(blob, file.name.replace(/\.[^.]+$/, '') + '.' + format);
          status.textContent = 'Done — video downloaded.';
        } catch (err) {
          console.error(err);
          status.textContent = 'Video conversion failed (see console).';
        } finally {
          try { ffmpeg.FS('unlink', 'input' + getFileExtension(file.name)); } catch(e){}
        }
        return;
      }

      status.textContent = 'Unsupported file type / target format combination.';
    }

    // helpers
    function fileToDataURL(file) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

    function loadImage(dataUrl) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = dataUrl;
      });
    }

    function downloadBlob(blob, name) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url);
    }

    function getFileExtension(name) {
      const m = name.match(/(\.[^.]+)$/);
      return m ? m[0] : '';
    }

  </script>
</body>
</html>
